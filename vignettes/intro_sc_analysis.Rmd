---
title: "Introduction to single cell RNA-seq analysis"
author: Rene Welch
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{intro_sc_analysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  message = FALSE, warning = FALSE, fig.align = "center",
  collapse = TRUE,
  comment = "#>"
)
```

## Workshop description

In exploring and analyzing single cell RNA sequencing data, there are a number of key concepts, such as filtering, scaling, dimensionality reduction, hypothesis testing, clustering and visualization, that need to be understood.

The idea behind this small session is to provide tools to start analyzing a single cell RNA-seq dataset, we are going to focus on how to utilize the R package Seurat to provide a dimensionality reduction visualization. These notes are based on this [tutorial](https://satijalab.org/seurat/articles/pbmc3k_tutorial.html)

### R / Bioconductor package used

* `scRNAseq`
* `Seurat`

## Introduction

There are many steps involved in analyzing a single cell RNA-seq experiment. Usually, we start by aligning the sequence reads into a reference genome to quantify the number of reads mapped to each gene. This results into a table of counts, which we are going to use to perform statistical analysis using R. For single cell RNA-seq data, there are many tools to perform this step, but today we are going to utilize from an already curated dataset, and show how to process it with the R package `Seurat`.

First, let's load all the packages we will need to analyze the data:

```{r, message=FALSE,warning=FALSE}
library(Seurat) ## main package that we are going to use
library(SingleCellExperiment)
library(scRNAseq) 
library(tidyverse) 
library(plotly)
library(cowplot)
```

## Getting the data

First, we need to download a dataset. Fortunately, the `scRNAseq` package provides a variety of already curated datasets:

```{r lung-data, message=FALSE, echo=TRUE,include=TRUE, eval=TRUE, warning=FALSE}
lung_data <- ZilionisLungData("mouse")
colnames(lung_data) <- make.unique(colnames(lung_data), sep = "_")
colData(lung_data)[["Barcode"]] <- colnames(lung_data)
logcounts(lung_data) <- as.matrix(log10(1 + counts(lung_data)))
lung_data <- as.Seurat(lung_data, project = "lung")
```

Now, Seurat provides all sorts of useful information on our dataset:

```{r include=TRUE,echo=TRUE,eval=TRUE}
lung_data
```

To access the metadata, i.e. information for each cell / droplet, we do:

```{r include=TRUE,echo=TRUE,eval=TRUE}
head(lung_data@meta.data)
```

This is a curated dataset, thus it already contains the cell labels. At the moment we are going to assume that we don't know that yet.

**Quick note:** This data could be a bit large for some laptops, so in case of trouble running this naalysis, then it could be useful to pick another dataset. To list the datasets provided by the `scRNAseq` package use:

```{r eval = FALSE}
listDatasets()
```

## Quality control

Usually to do a quick quality control, the idea behind this step is that we would like to not have cells in our dataset with an abnormally large / small # of genes (we quantify the # of genes for a cell/droplet as the # of genes with at least 1 read). The reasons for them are:

- Cell doublets or multiplets may exhibit and abnormally high number of genes
- Low-quality cells or empty droplets will often have few genes

First, we add a pair of QC metric to the `meta.data`, and the explore their distribution:

```{r brief-qc, include=TRUE,echo=TRUE,eval=TRUE, out.width = "75%", fig.height=4,fig.width=7}
lung_data[["nCount_RNA"]] <- colSums(lung_data[["RNA"]]@counts)
lung_data[["nFeature_RNA"]] <- apply(lung_data[["RNA"]]@counts, 2, function(x)sum(x > 0))
VlnPlot(lung_data, features = c("nFeature_RNA", "nCount_RNA"), ncol = 2)
```

Then, we compare those quantities, as expected both metrics are very correlated:

```{r metrics-corr, fig.width=6,fig.height=4, out.width="80%"}
FeatureScatter(lung_data, feature1 = "nCount_RNA", feature2 = "nFeature_RNA",
               cols = "black") +
    geom_smooth(se = FALSE) +
    geom_vline(xintercept = 12e3, linetype = 2, colour = "red") +
    geom_hline(yintercept = 3e3, linetype = 2, colour = "red")
```

We remove the cells with more than 12K reads or more than 3K genes and normalize the data, the default method uses logarithms with a _pseudo-count_ and a scaling factor, which could be good for a first pass. However, many more methods for normalization have been developed, thus it may is possible that there are methods more useful for different datasets.


```{r subset-normalize}
lung_data <- subset(lung_data,
                    subset = nFeature_RNA <= 3e3 & nFeature_RNA <= 12e3)
## writing the default parameters, explicitly
lung_data <- NormalizeData(lung_data,
                           normalization.method = "LogNormalize",
                           scale.factor = 10000)
```

## Identification of most variable genes



```{r variable-features, include=TRUE,echo=TRUE,eval=TRUE,message=FALSE,warning=FALSE, fig.width = 7,fig.height=5,out.width="80%"}

lung_data <- FindVariableFeatures(lung_data, selection.method = "vst",
                                  nfeatures = 5000)
plot1 <- VariableFeaturePlot(lung_data, log = TRUE)
top_genes <- head(VariableFeatures(lung_data), 20)
LabelPoints(plot1, points = top_genes, repel = TRUE)

```


## Principal Components Analysis

```{r pca-analysis}

variable_genes <- VariableFeatures(object = lung_data)
lung_data <- ScaleData(lung_data, features = variable_genes)
lung_data <- RunPCA(lung_data, features = VariableFeatures(object = lung_data))

```



```{r pick-pc-components}

ElbowPlot(lung_data)

```


## Clustering

```{r clustering}
lung_data <- FindNeighbors(lung_data, dims = 1:10)
lung_data <- FindClusters(lung_data, resolution = 0.1)
```

## UMAP

```{r umap-analysis}
lung_data <- RunUMAP(lung_data, dims = 1:10)
nclusters <- nlevels(lung_data@meta.data$seurat_clusters)
colors <- pals::alphabet2(nclusters)
names(colors) <- NULL
DimPlot(lung_data, reduction = "umap", cols = colors)
```

## Final thoughts


